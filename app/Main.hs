{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}

module Main where

import Web.Scotty
import Network.Wai
import Network.Wai.Middleware.Static
import Data.Foldable
import Data.Aeson hiding(json)
import Data.Text(Text)
import System.Directory
import Data.Maybe
import System.IO
import System.FilePath
import System.Process
import GHC.Generics
import GHC.IO.Handle
import Control.Concurrent.MVar
import Control.Monad
import Control.Monad.IO.Class(liftIO)
import Control.Concurrent
import Data.Time.Clock
import qualified Control.Monad.State.Lazy as S
import qualified Data.ByteString.Lazy as B

type ProcessStateAction = S.StateT ProcessState IO ()
type ProcessState = (ProcessHandle, Handle, UTCTime)

data Config = Config {
    staticWebsiteDirectory :: String,
    videoStreamDirectory :: String,
    videoProcessCommand :: String,
    port :: Int,
    secondsBetweenIdleChecks :: Int,
    maxIdleSeconds :: Int
} deriving Generic

instance FromJSON Config where
    parseJSON = genericParseJSON defaultOptions

main :: IO ()
main = do
    config <- fmap (fromJust . decode) (B.readFile "config.json") :: IO Config
    let staticDirectory = staticWebsiteDirectory config
        streamDirectory = videoStreamDirectory config
        processCommand  = videoProcessCommand config
        timeBetweenIdleChecks  = fromRational $ toRational $ secondsBetweenIdleChecks config
        maxIdle    = fromRational $ toRational $ maxIdleSeconds config
    var <- newMVar Nothing
    cleanVideoFiles streamDirectory
    runAtInterval timeBetweenIdleChecks (stopVideoProcessIfUnused maxIdle streamDirectory var)
    scotty (port config) $ do
        -- When the stream is requested, ensure the video process server is running before serving the file
        middleware $ performAction ["video", "stream.m3u8"] (ensureVideoProcessIsRunning streamDirectory processCommand var)
        -- Serve video files generated by the video process
        middleware $ staticPolicy (policyIgnorePrefix "video/" >-> addBase streamDirectory)
        -- Serve files up in the static directory
        middleware $ staticPolicy (only [("", staticDirectory </> "index.html")] <|> addBase staticDirectory)

-- |Middleware that performs an action if the url is matched
performAction :: [Text] -> IO () -> Middleware
performAction path action app req sendResponse = do
    when (path == pathInfo req) action
    app req sendResponse

-- |Requires the url has a given prefix but doesn't include the prefix in the mapped file path
-- Eg: policyIgnorePrefix a/ will match /a/b/c/d and will map it to /b/c/d
policyIgnorePrefix :: String -> Policy
policyIgnorePrefix prefix = hasPrefix prefix >-> policy (Just . drop (length prefix))

ensureVideoProcessIsRunning :: FilePath -> FilePath -> MVar (Maybe ProcessState) -> IO ()
ensureVideoProcessIsRunning streamPath scriptPath var = modifyMVar_ var modify where
    modify (Just (p, stdin, _)) = getCurrentTime >>= \t -> return $ Just (p, stdin, t)
    modify Nothing = do
        (p, stdin) <- startVideoProcess streamPath scriptPath
        t <- getCurrentTime
        return $ Just (p, stdin, t)

stopVideoProcessIfUnused :: NominalDiffTime -> FilePath -> MVar (Maybe ProcessState) -> IO ()
stopVideoProcessIfUnused maxIdle streamPath var = modifyMVar_ var modify where
    modify Nothing = return Nothing
    modify cur@(Just (p, stdin, t)) = do
        tNow <- getCurrentTime
        if diffUTCTime tNow t > maxIdle then stopVideoProcess streamPath (p, stdin) >> return Nothing
        else return cur

startVideoProcess :: FilePath -> FilePath -> IO (ProcessHandle, Handle)
startVideoProcess streamPath scriptPath = do
    p <- spawnProcessWithInput scriptPath [streamPath]
    -- give video 10s to start capturing
    threadDelay 10000000
    return p
    where
        spawnProcessWithInput cmd args = do
            (Just stdin,_,_,p) <- createProcess_ "videoStreamer" ((proc cmd args) { std_in = CreatePipe })
            return (p, stdin)

stopVideoProcess :: FilePath -> (ProcessHandle, Handle) -> IO ()
stopVideoProcess streamPath (p, stdin) = do
    isRunning <- hIsOpen stdin
    when isRunning $ do
        hPutStrLn stdin "x" -- x is the signal to stop processing
        hClose stdin
        waitForProcess p
        cleanVideoFiles streamPath

cleanVideoFiles :: FilePath -> IO ()
cleanVideoFiles dir = do
    files <- listDirectory dir
    traverse_ removeFile
        $ map (dir </>)
        $ filter (\f -> let e = takeExtension f in e == ".ts" || e == ".m3u8") files

-- |Runs an action at the specified interval on a new thread
runAtInterval :: DiffTime -> IO () -> IO ()
runAtInterval dt a = void $ forkIO (forever (a >> threadDelay (floor dt * 1000000)))
